import { CSSProperties, useCallback, useEffect, useMemo, useRef, useState } from 'react';



import { formatTopStatValue, formatWithCommas } from './stats/utils/dashboardUtils';
import { OFFENSE_METRICS, DEFENSE_METRICS, SUPPORT_METRICS, HEALING_METRICS } from './stats/statsMetrics';
import { useStatsNavigation } from './stats/hooks/useStatsNavigation';
import { useStatsUploads } from './stats/hooks/useStatsUploads';
import { useStatsScreenshot } from './stats/hooks/useStatsScreenshot';
import { useStatsAggregation } from './stats/hooks/useStatsAggregation';
import { useApmStats } from './stats/hooks/useApmStats';
import { useSkillCharts } from './stats/hooks/useSkillCharts';
import { getProfessionColor, getProfessionIconPath } from '../shared/professionUtils';
import { IconAliasManifest, IconManifest, SkillIdNameMap, getUnknownSkillIconUrl, guessIconUrl, loadIconAliases, loadIconManifest, loadSkillIdNames, normalizeIconKey, resolveIconUrl } from '../shared/iconManifest';
import { BoonCategory, BoonMetric, formatBoonMetricDisplay, getBoonMetricValue } from '../shared/boonGeneration';
import { DEFAULT_MVP_WEIGHTS, DEFAULT_STATS_VIEW_SETTINGS, DEFAULT_WEB_UPLOAD_STATE, DisruptionMethod, IMvpWeights, IStatsViewSettings, IWebUploadState } from './global.d';
import type { SkillUsageSummary } from './stats/statsTypes';


import { SkillUsageSection } from './stats/sections/SkillUsageSection';
import { ApmSection } from './stats/sections/ApmSection';
import { OffenseSection } from './stats/sections/OffenseSection';
import { ConditionsSection } from './stats/sections/ConditionsSection';
import { BoonOutputSection } from './stats/sections/BoonOutputSection';
import { DefenseSection } from './stats/sections/DefenseSection';
import { SupportSection } from './stats/sections/SupportSection';
import { HealingSection } from './stats/sections/HealingSection';
import { SpecialBuffsSection } from './stats/sections/SpecialBuffsSection';
import { OverviewSection } from './stats/sections/OverviewSection';
import { FightBreakdownSection } from './stats/sections/FightBreakdownSection';
import { TopPlayersSection } from './stats/sections/TopPlayersSection';
import { TopSkillsSection } from './stats/sections/TopSkillsSection';
import { SquadCompositionSection } from './stats/sections/SquadCompositionSection';
import { TimelineSection } from './stats/sections/TimelineSection';
import { MapDistributionSection } from './stats/sections/MapDistributionSection';
import { StatsHeader } from './stats/ui/StatsHeader';
import { WebUploadBanner } from './stats/ui/WebUploadBanner';
import { DevMockBanner } from './stats/ui/DevMockBanner';
import { StatsMobileNav } from './stats/ui/StatsMobileNav';

interface StatsViewProps {
    logs: ILogData[];
    onBack: () => void;
    mvpWeights?: IMvpWeights;
    statsViewSettings?: IStatsViewSettings;
    webUploadState?: IWebUploadState;
    onWebUpload?: (payload: { meta: any; stats: any }) => Promise<void> | void;
    disruptionMethod?: DisruptionMethod;
    precomputedStats?: any;
    embedded?: boolean;
    sectionVisibility?: (id: string) => boolean;
    dashboardTitle?: string;
    uiTheme?: 'classic' | 'modern';
}

const sidebarListClass = 'max-h-80 overflow-y-auto space-y-1 pr-1';
const NON_DAMAGING_CONDITIONS = new Set(['Vulnerability', 'Weakness', 'Blinded', 'Chilled', 'Crippled', 'Slow', 'Taunt', 'Fear', 'Immobile']);

export function StatsView({ logs, onBack, mvpWeights, statsViewSettings, webUploadState, onWebUpload, disruptionMethod, precomputedStats, embedded = false, sectionVisibility, dashboardTitle, uiTheme }: StatsViewProps) {
    const activeMvpWeights = mvpWeights || DEFAULT_MVP_WEIGHTS;
    const activeStatsViewSettings = statsViewSettings || DEFAULT_STATS_VIEW_SETTINGS;
    const activeWebUploadState = webUploadState || DEFAULT_WEB_UPLOAD_STATE;
    const showTopStats = activeStatsViewSettings.showTopStats;
    const showMvp = activeStatsViewSettings.showMvp;
    const roundCountStats = activeStatsViewSettings.roundCountStats;
    const topStatsMode = activeStatsViewSettings.topStatsMode || 'total';
    const uploadingWeb = activeWebUploadState.uploading;
    const webUploadMessage = activeWebUploadState.message;
    const webUploadUrl = activeWebUploadState.url;
    const webUploadBuildStatus = activeWebUploadState.buildStatus;
    const devMockAvailable = !embedded && import.meta.env.DEV && !!window.electronAPI?.mockWebReport;

    // --- Hook Integration ---
    const {
        stats,
        skillUsageData: computedSkillUsageData
    } = useStatsAggregation({ logs, precomputedStats, mvpWeights, statsViewSettings, disruptionMethod });

    const skillUsageData = (precomputedStats?.skillUsageData ?? computedSkillUsageData) as SkillUsageSummary;

    useEffect(() => {
        console.log('[StatsView] Stats Aggregation Result:', {
            stats,
            skillUsageData,
            validLogsCount: stats.totalWinner + stats.totalLoser, // approximate
            overview: stats.overview
        });
    }, [stats, skillUsageData]);

    const skillUsageAvailable = skillUsageData.players.length > 0;

    const {
        mobileNavOpen,
        setMobileNavOpen,
        activeNavId,
        scrollContainerRef,
        tocItems,
        scrollToSection,
        stepSection
    } = useStatsNavigation(embedded);

    const {
        devMockUploadState,
        webCopyStatus,
        setWebCopyStatus,
        handleWebUpload,
        handleDevMockUpload
    } = useStatsUploads({
        logs,
        stats,
        skillUsageData,
        activeStatsViewSettings: statsViewSettings || DEFAULT_STATS_VIEW_SETTINGS,
        uiTheme: uiTheme || 'classic',
        embedded,
        onWebUpload
    });

    const {
        sharing,
        handleShare
    } = useStatsScreenshot(embedded);
    const mvpStatWeightKeys: Record<string, keyof IMvpWeights> = {
        'Down Contribution': 'downContribution',
        'Healing': 'healing',
        'Cleanses': 'cleanses',
        'Strips': 'strips',
        'Stability': 'stability',
        'CC': 'cc',
        'Revives': 'revives',
        'Distance to Tag': 'distanceToTag',
        'Participation': 'participation',
        'Dodging': 'dodging',
        'DPS': 'dps',
        'Damage': 'damage'
    };
    const isMvpStatEnabled = (name: string) => {
        const key = mvpStatWeightKeys[name];
        if (!key) return true;
        return activeMvpWeights[key] > 0;
    };

    const [expandedLeader, setExpandedLeader] = useState<string | null>(null);
    const [activeBoonTab, setActiveBoonTab] = useState<string | null>(null);
    const [activeBoonCategory, setActiveBoonCategory] = useState<BoonCategory>('totalBuffs');
    const [activeBoonMetric, setActiveBoonMetric] = useState<BoonMetric>('total');
    const [boonSearch, setBoonSearch] = useState('');
    const [activeSpecialTab, setActiveSpecialTab] = useState<string | null>(null);
    const [specialSearch, setSpecialSearch] = useState('');
    const [offenseSearch, setOffenseSearch] = useState('');
    const [defenseSearch, setDefenseSearch] = useState('');
    const [conditionSearch, setConditionSearch] = useState('');
    const [conditionDirection, setConditionDirection] = useState<'outgoing' | 'incoming'>('outgoing');
    const [supportSearch, setSupportSearch] = useState('');
    const [activeOffenseStat, setActiveOffenseStat] = useState<string>('damage');
    const [activeDefenseStat, setActiveDefenseStat] = useState<string>('damageTaken');
    const [activeConditionName, setActiveConditionName] = useState<string>('all');
    const [conditionSort, setConditionSort] = useState<{ key: 'applications' | 'damage'; dir: 'asc' | 'desc' }>({
        key: 'damage',
        dir: 'desc'
    });
    const isNonDamagingCondition = activeConditionName !== 'all' && NON_DAMAGING_CONDITIONS.has(activeConditionName);
    const showConditionDamage = !isNonDamagingCondition;
    const conditionGridClass = showConditionDamage
        ? 'grid-cols-[0.4fr_1.6fr_1fr_1fr]'
        : 'grid-cols-[0.4fr_1.6fr_1fr]';
    const effectiveConditionSort = showConditionDamage
        ? conditionSort
        : { key: 'applications', dir: conditionSort.key === 'applications' ? conditionSort.dir : 'desc' };
    const [activeSupportStat, setActiveSupportStat] = useState<string>('condiCleanse');
    const [activeHealingMetric, setActiveHealingMetric] = useState<string>('healing');
    const [healingCategory, setHealingCategory] = useState<'total' | 'squad' | 'group' | 'self' | 'offSquad'>('total');
    const [activeResUtilitySkill, setActiveResUtilitySkill] = useState<string>('all');
    const [offenseViewMode, setOffenseViewMode] = useState<'total' | 'per1s' | 'per60s'>('total');
    const [defenseViewMode, setDefenseViewMode] = useState<'total' | 'per1s' | 'per60s'>('total');
    const [supportViewMode, setSupportViewMode] = useState<'total' | 'per1s' | 'per60s'>('total');
    const [cleanseScope, setCleanseScope] = useState<'squad' | 'all'>('all');
    const [timelineFriendlyScope, setTimelineFriendlyScope] = useState<'squad' | 'squadAllies'>('squad');



    const [skillUsagePlayerFilter, setSkillUsagePlayerFilter] = useState('');
    const [skillUsageSkillFilter, setSkillUsageSkillFilter] = useState('');
    const [selectedSkillId, setSelectedSkillId] = useState<string | null>(null);
    const [selectedPlayers, setSelectedPlayers] = useState<string[]>([]);
    const [hoveredSkillPlayer, setHoveredSkillPlayer] = useState<string[]>([]);
    const [expandedSection, setExpandedSection] = useState<string | null>(null);
    const [expandedSectionClosing, setExpandedSectionClosing] = useState(false);
    const expandedCloseTimerRef = useRef<number | null>(null);
    const [fightBreakdownTab, setFightBreakdownTab] = useState<'sizes' | 'outcomes' | 'damage' | 'barrier'>('sizes');
    const [skillUsageView, setSkillUsageView] = useState<'total' | 'perSecond'>('total');
    const isSkillUsagePerSecond = skillUsageView === 'perSecond';
    const [expandedSkillUsageClass, setExpandedSkillUsageClass] = useState<string | null>(null);
    const [apmView, setApmView] = useState<'total' | 'perSecond'>('total');
    const [activeApmSpec, setActiveApmSpec] = useState<string | null>(null);
    const [expandedApmSpec, setExpandedApmSpec] = useState<string | null>(null);
    const [activeApmSkillId, setActiveApmSkillId] = useState<string | null>(null);
    const [apmSkillSearch, setApmSkillSearch] = useState('');

    const { apmSpecBuckets: apmSpecTables } = useApmStats(skillUsageData);

    const {
        playerMapByKey,
        playerTotalsForSkill,
        skillChartData,
        skillChartMaxY,
        groupedSkillUsagePlayers
    } = useSkillCharts({
        skillUsageData,
        selectedSkillId,
        selectedPlayers: new Set(selectedPlayers),
        skillUsageView: skillUsageView === 'perSecond' ? 'perSecond' : 'total'
    });

    const conditionSummary = conditionDirection === 'outgoing' ? stats.outgoingConditionSummary : stats.incomingConditionSummary;
    const conditionPlayers = conditionDirection === 'outgoing' ? stats.outgoingConditionPlayers : stats.incomingConditionPlayers;

    // Define classMaxTotals to fix undefined variable error
    const classMaxTotals = useMemo(() => {
        const totals: Record<string, number> = {};
        playerTotalsForSkill.forEach((total, playerKey) => {
            const player = playerMapByKey.get(playerKey);
            if (!player) return;
            const prof = player.profession;
            if (!totals[prof] || total > totals[prof]) {
                totals[prof] = total;
            }
        });
        return totals;
    }, [playerTotalsForSkill, playerMapByKey]);

    const isSectionVisible = (id: string) => (sectionVisibility ? sectionVisibility(id) : true);
    const sectionClass = (id: string, base: string) => {
        const visible = isSectionVisible(id);
        return `${base} transition-[opacity,transform] duration-700 ease-in-out ${visible
            ? 'opacity-100 translate-y-0 max-h-[99999px]'
            : 'opacity-0 -translate-y-2 max-h-0 h-0 min-h-0 overflow-hidden pointer-events-none p-0 !p-0 m-0 !mb-0 !mt-0 border-0 !border-0 border-transparent'}`;
    };
    const orderedSectionIds = [
        'overview',
        'fight-breakdown',
        'top-players',
        'top-skills-outgoing',
        'squad-composition',
        'timeline',
        'map-distribution',
        'boon-output',
        'offense-detailed',
        'conditions-outgoing',
        'defense-detailed',
        'support-detailed',
        'healing-stats',
        'special-buffs',
        'skill-usage',
        'apm-stats'
    ];
    const firstVisibleSectionId = orderedSectionIds.find((id) => isSectionVisible(id)) || null;
    const isFirstVisibleSection = (id: string) => id === firstVisibleSectionId;







    const classRankByPlayer = useMemo(() => {
        const ranks = new Map<string, number>();
        const grouped = new Map<string, Array<{ key: string; total: number }>>();
        selectedPlayers.forEach((playerKey) => {
            const player = playerMapByKey.get(playerKey);
            if (!player) return;
            const total = playerTotalsForSkill.get(playerKey) ?? 0;
            const list = grouped.get(player.profession) || [];
            list.push({ key: playerKey, total });
            grouped.set(player.profession, list);
        });
        grouped.forEach((list) => {
            list.sort((a, b) => b.total - a.total);
            list.forEach((entry, index) => {
                ranks.set(entry.key, index);
            });
        });
        return ranks;
    }, [selectedPlayers, playerMapByKey, playerTotalsForSkill]);

    const lineDashPatterns = ['0', '12 3', '8 3', '6 3', '4 3', '2 3'];

    const getLineColorForPlayer = (playerKey: string) => {
        const player = playerMapByKey.get(playerKey);
        const baseColor = getProfessionColor(player?.profession || '') || '#38bdf8';
        const total = playerTotalsForSkill.get(playerKey) ?? 0;
        const maxTotal = player?.profession ? classMaxTotals[player.profession] || 1 : 1;
        const ratio = maxTotal > 0 ? total / maxTotal : 1;
        const factor = 0.35 + ratio * 0.65;
        return adjustHexColor(baseColor, factor);
    };

    const getLineDashForPlayer = (playerKey: string) => {
        const rank = classRankByPlayer.get(playerKey) ?? 0;
        return lineDashPatterns[rank % lineDashPatterns.length];
    };

    const getLineStrokeColor = (playerKey: string, isSelected: boolean, hasSelection: boolean) => {
        if (!hasSelection) {
            return getLineColorForPlayer(playerKey);
        }
        const player = playerMapByKey.get(playerKey);
        const baseColor = getProfessionColor(player?.profession || '') || '#38bdf8';
        return isSelected ? adjustHexColor(baseColor, 1.2) : adjustHexColor(baseColor, 0.5);
    };

    const adjustHexColor = (hex: string, factor: number) => { // Keep adjustHexColor
        const cleaned = hex.replace('#', '');
        if (cleaned.length !== 6) return hex;
        const clamp = (value: number) => Math.max(0, Math.min(255, value));
        const parse = (start: number) => Number.parseInt(cleaned.slice(start, start + 2), 16);
        const toHex = (value: number) => clamp(Math.round(value)).toString(16).padStart(2, '0');
        const r = parse(0);
        const g = parse(2);
        const b = parse(4);
        return `#${toHex(r * factor)}${toHex(g * factor)}${toHex(b * factor)}`;
    };

    const skillNameById = useMemo(() => {
        const map = new Map<string, string>();
        skillUsageData.skillOptions.forEach((option) => {
            map.set(option.id, option.name);
        });
        return map;
    }, [skillUsageData.skillOptions]);

    const skillBarData = useMemo(() => {
        if (selectedPlayers.length === 0) return [];
        const totals = new Map<string, number>();
        const classTotals = new Map<string, number>();
        let totalActiveSeconds = 0;
        selectedPlayers.forEach((playerKey) => {
            const player = playerMapByKey.get(playerKey);
            if (!player) return;
            totalActiveSeconds += player.totalActiveSeconds || 0;
            Object.entries(player.skillTotals || {}).forEach(([skillId, count]) => {
                totals.set(skillId, (totals.get(skillId) || 0) + Number(count || 0));
            });
            const profession = player.profession || 'Unknown';
            classTotals.set(profession, (classTotals.get(profession) || 0) + (player.totalActiveSeconds || 0));
        });
        const term = skillUsageSkillFilter.trim().toLowerCase();
        const isPerSecond = skillUsageView === 'perSecond';
        const dominantProfession = Array.from(classTotals.entries())
            .sort((a, b) => b[1] - a[1])[0]?.[0] || 'Unknown';
        const dominantColor = getProfessionColor(dominantProfession) || '#38bdf8';
        const accentFallback = '#64748b';
        const entries = Array.from(totals.entries())
            .map(([skillId, total]) => {
                const name = skillNameById.get(skillId) || skillId;
                const value = isPerSecond && totalActiveSeconds > 0 ? total / totalActiveSeconds : total;
                return { skillId, name, total: value };
            })
            .filter((entry) => entry.total > 0 && (!term || entry.name.toLowerCase().includes(term)))
            .sort((a, b) => b.total - a.total);
        return entries.map((entry, index) => ({
            ...entry,
            color: index === 0 ? dominantColor : adjustHexColor(dominantColor, 0.85 - Math.min(index * 0.06, 0.4)) || accentFallback
        }));
    }, [selectedPlayers, playerMapByKey, skillUsageSkillFilter, skillUsageView, skillNameById]);

    useEffect(() => {
        if (skillBarData.length === 0) {
            if (selectedSkillId !== null) setSelectedSkillId(null);
            return;
        }
        if (!selectedSkillId || !skillBarData.some((entry) => entry.skillId === selectedSkillId)) {
            setSelectedSkillId(skillBarData[0].skillId);
        }
    }, [skillBarData, selectedSkillId, setSelectedSkillId]);

    const selectedSkillName = skillUsageData.skillOptions.find((option) => option.id === selectedSkillId)?.name || '';
    const skillUsageReady = skillUsageAvailable && Boolean(selectedSkillId) && selectedPlayers.length > 0;

    const ALL_SKILLS_KEY = '__all__';

    const apmSpecAvailable = skillUsageAvailable && apmSpecTables.length > 0;
    const activeApmSpecTable = useMemo(
        () => apmSpecTables.find((spec) => spec.profession === activeApmSpec) ?? null,
        [apmSpecTables, activeApmSpec]
    );
    const isAllApmSkills = activeApmSkillId === ALL_SKILLS_KEY;
    const activeApmSkill = useMemo(
        () => activeApmSpecTable?.skills?.find((skill) => skill.id === activeApmSkillId) ?? null,
        [activeApmSpecTable, activeApmSkillId]
    );

    useEffect(() => {
        if (apmSpecTables.length === 0) {
            if (activeApmSpec !== null) {
                setActiveApmSpec(null);
            }
            if (expandedApmSpec !== null) {
                setExpandedApmSpec(null);
            }
            return;
        }
        if (!activeApmSpec || !apmSpecTables.some((spec) => spec.profession === activeApmSpec)) {
            const nextSpec = apmSpecTables[0].profession;
            setActiveApmSpec(nextSpec);
            setExpandedApmSpec(null);
        }
    }, [apmSpecTables, activeApmSpec, expandedApmSpec]);

    useEffect(() => {
        if (!activeApmSpecTable || activeApmSpecTable.skills.length === 0) {
            if (activeApmSkillId !== null) {
                setActiveApmSkillId(null);
            }
            return;
        }
        const hasSkill = activeApmSpecTable.skills.some((skill) => skill.id === activeApmSkillId);
        if (!activeApmSkillId || (!hasSkill && activeApmSkillId !== ALL_SKILLS_KEY)) {
            setActiveApmSkillId(ALL_SKILLS_KEY);
        }
    }, [activeApmSpecTable, activeApmSkillId]);

    const togglePlayerSelection = (playerKey: string) => {
        setSelectedPlayers((prev) => {
            if (prev.includes(playerKey)) {
                return prev.filter((key) => key !== playerKey);
            }
            return [...prev, playerKey];
        });
    };

    const removeSelectedPlayer = (playerKey: string) => {
        setSelectedPlayers((prev) => prev.filter((key) => key !== playerKey));
    };

    const filteredBoonTables = useMemo(() => {
        const term = boonSearch.trim().toLowerCase();
        if (!term) return stats.boonTables;
        return stats.boonTables.filter((boon: any) => boon.name.toLowerCase().includes(term));
    }, [stats.boonTables, boonSearch]);
    const activeBoonTable = useMemo(() => {
        if (!activeBoonTab) return null;
        return stats.boonTables.find((boon: any) => boon.id === activeBoonTab) ?? null;
    }, [stats.boonTables, activeBoonTab]);
    const filteredSpecialTables = useMemo(() => {
        const term = specialSearch.trim().toLowerCase();
        const sorted = [...stats.specialTables].sort((a: any, b: any) => a.name.localeCompare(b.name));
        if (!term) return sorted;
        return sorted.filter((buff: any) => buff.name.toLowerCase().includes(term));
    }, [stats.specialTables, specialSearch]);
    const activeSpecialTable = useMemo(() => {
        if (!activeSpecialTab) return null;
        return stats.specialTables.find((buff: any) => buff.id === activeSpecialTab) ?? null;
    }, [stats.specialTables, activeSpecialTab]);

    useEffect(() => {
        if (!stats.boonTables || stats.boonTables.length === 0) return;
        if (!activeBoonTab || !stats.boonTables.some((tab: any) => tab.id === activeBoonTab)) {
            setActiveBoonTab(stats.boonTables[0].id);
        }
    }, [stats.boonTables, activeBoonTab]);

    useEffect(() => {
        if (!stats.specialTables || stats.specialTables.length === 0) return;
        if (!activeSpecialTab || !stats.specialTables.some((tab: any) => tab.id === activeSpecialTab)) {
            setActiveSpecialTab(stats.specialTables[0].id);
        }
    }, [stats.specialTables, activeSpecialTab]);

    useEffect(() => {
        const clearSelection = () => {
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                selection.removeAllRanges();
            }
        };
        const preventChartSelection = (event: Event) => {
            const target = event.target as HTMLElement | null;
            if (!target?.closest?.('.recharts-wrapper')) return;
            event.preventDefault();
            clearSelection();
        };
        document.addEventListener('selectstart', preventChartSelection);
        document.addEventListener('mousedown', preventChartSelection);
        document.addEventListener('mousemove', preventChartSelection);
        document.addEventListener('dragstart', preventChartSelection);
        return () => {
            document.removeEventListener('selectstart', preventChartSelection);
            document.removeEventListener('mousedown', preventChartSelection);
            document.removeEventListener('mousemove', preventChartSelection);
            document.removeEventListener('dragstart', preventChartSelection);
        };
    }, []);



    const openExpandedSection = (sectionId: string) => {
        if (expandedCloseTimerRef.current) {
            window.clearTimeout(expandedCloseTimerRef.current);
            expandedCloseTimerRef.current = null;
        }
        setExpandedSectionClosing(false);
        setExpandedSection(sectionId);
    };

    const closeExpandedSection = () => {
        if (!expandedSection) return;
        if (expandedCloseTimerRef.current) {
            window.clearTimeout(expandedCloseTimerRef.current);
        }
        setExpandedSectionClosing(true);
        expandedCloseTimerRef.current = window.setTimeout(() => {
            setExpandedSection(null);
            setExpandedSectionClosing(false);
            expandedCloseTimerRef.current = null;
        }, 160);
    };

    useEffect(() => {
        if (!expandedSection) return;
        const handleKeyDown = (event: KeyboardEvent) => {
            if (event.key === 'Escape') {
                closeExpandedSection();
            }
        };
        const prevBodyOverflow = document.body.style.overflow;
        const prevHtmlOverflow = document.documentElement.style.overflow;
        document.body.style.overflow = 'hidden';
        document.documentElement.style.overflow = 'hidden';
        window.addEventListener('keydown', handleKeyDown);
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
            document.body.style.overflow = prevBodyOverflow;
            document.documentElement.style.overflow = prevHtmlOverflow;
        };
    }, [expandedSection]);

    const sortByCountDesc = (a: any, b: any) => {
        const diff = (b?.value || 0) - (a?.value || 0);
        if (diff !== 0) return diff;
        return String(a?.name || '').localeCompare(String(b?.name || ''));
    };
    const sortedSquadClassData = [...stats.squadClassData].sort(sortByCountDesc);
    const sortedEnemyClassData = [...stats.enemyClassData].sort(sortByCountDesc);

    const containerClass = embedded
        ? 'stats-view min-h-screen flex flex-col p-0 w-full max-w-none'
        : 'stats-view h-full flex flex-col p-1 w-full max-w-6xl mx-auto overflow-hidden';
    const scrollContainerClass = embedded
        ? `stats-sections space-y-0 min-h-0 px-3 pb-3 pt-3 sm:px-4 sm:pb-4 sm:pt-4 rounded-xl bg-black/20 border border-white/5 ${expandedSection ? '' : 'backdrop-blur-xl'
        }`
        : `flex-1 overflow-y-auto pr-2 space-y-6 min-h-0 bg-black/30 border border-white/5 p-4 rounded-xl ${expandedSection ? '' : 'backdrop-blur-2xl'
        }`;
    const scrollContainerStyle: CSSProperties | undefined = embedded
        ? {
            backgroundColor: 'rgba(3, 7, 18, 0.75)',
            backgroundImage: 'linear-gradient(160deg, rgba(var(--accent-rgb), 0.12), rgba(var(--accent-rgb), 0.04) 70%)'
        }
        : undefined;

    const formatSkillUsageValue = (val: number) => {
        return skillUsageView === 'perSecond'
            ? val.toFixed(1)
            : Math.round(val).toLocaleString();
    };

    const formatCastRateValue = (val: number) => val.toFixed(1);
    const formatCastCountValue = (val: number) => Math.round(val).toLocaleString();
    const formatApmValue = (val: any) => {
        if (typeof val === 'number' && Number.isFinite(val)) return val.toFixed(1);
        return '0.0';
    };

    const [gameIconManifest, setGameIconManifest] = useState<IconManifest | null>(null);
    const [iconAliases, setIconAliases] = useState<IconAliasManifest | null>(null);
    const [skillIdNames, setSkillIdNames] = useState<SkillIdNameMap | null>(null);

    useEffect(() => {
        let isMounted = true;
        Promise.all([
            loadIconManifest(),
            loadIconAliases(),
            loadSkillIdNames()
        ])
            .then(([gameManifest, aliases, skillNames]) => {
                if (!isMounted) return;
                setGameIconManifest(gameManifest);
                setIconAliases(aliases);
                setSkillIdNames(skillNames);
            })
            .catch(() => {
                if (!isMounted) return;
                setGameIconManifest(null);
                setIconAliases(null);
                setSkillIdNames(null);
            });
        return () => {
            isMounted = false;
        };
    }, []);

    const stripParenthetical = useCallback((name: string) => {
        if (!name) return '';
        return name.replace(/\s*\([^)]*\)\s*/g, ' ').replace(/\s+/g, ' ').trim();
    }, []);

    const resolveAliasName = useCallback(
        (name: string) => {
            if (!name) return null;
            if (/primal rage/i.test(name)) return null;
            const lower = name.toLowerCase();
            if (lower.includes('arrow') && lower.includes('fire') && lower.includes('arrows')) {
                if (/(crippling|reaping|staggering|suffering)/i.test(name)) return 'Fire Crippling Arrows';
                if (/(barbed|merciless|penetrating|exsanguinating)/i.test(name)) return 'Fire Barbed Arrows';
                return 'Fire Arrow Cart';
            }
            if (/toxic.*volley/i.test(name)) return 'Toxic Unveiling Volley';
            const arrowCartAliasMap: Record<string, string> = {
                fire: 'Fire Arrow Cart',
                fire_improved_arrows: 'Fire Arrow Cart',
                fire_distant_volley: 'Fire Arrow Cart',
                fire_devastating_arrows: 'Fire Arrow Cart',
                fire_crippling_arrows: 'Fire Crippling Arrows',
                fire_improved_crippling_arrows: 'Fire Crippling Arrows',
                fire_reaping_arrows: 'Fire Crippling Arrows',
                fire_staggering_arrows: 'Fire Crippling Arrows',
                fire_suffering_arrows: 'Fire Crippling Arrows',
                fire_barbed_arrows: 'Fire Barbed Arrows',
                fire_improved_barbed_arrows: 'Fire Barbed Arrows',
                fire_penetrating_sniper_arrows: 'Fire Barbed Arrows',
                fire_exsanguinating_arrows: 'Fire Barbed Arrows',
                fire_merciless_arrows: 'Fire Barbed Arrows',
                toxic_unveiling_volley: 'Toxic Unveiling Volley'
            };
            const normalized = normalizeIconKey(name);
            const arrowAlias = arrowCartAliasMap[normalized];
            if (arrowAlias) return arrowAlias;
            const direct = iconAliases?.iconAliases?.[normalizeIconKey(name)];
            if (direct) return direct;
            const sigilMatch = name.match(/sigil of ([^)]+)/i);
            if (sigilMatch) {
                const sigilName = sigilMatch[1].trim();
                if (sigilName) {
                    if (/minor\s*\/\s*major\s*\/\s*superior/i.test(name)) {
                        return `Superior Sigil of ${sigilName}`;
                    }
                    return `Sigil of ${sigilName}`;
                }
            }
            return null;
        },
        [iconAliases]
    );

    const resolveTraitAliasName = useCallback(
        (name: string) => {
            if (!name || /primal rage/i.test(name)) return null;
            if (!iconAliases?.traitAliases) return null;
            const key = normalizeIconKey(name);
            return iconAliases.traitAliases[key] || null;
        },
        [iconAliases]
    );


    const resolveIcon = useCallback(
        (name: string) => {
            return resolveIconUrl(gameIconManifest, name) || (!gameIconManifest ? guessIconUrl(name) : null);
        },
        [gameIconManifest]
    );

    const isArrowCartAlias = useCallback((name: string | null) => {
        if (!name) return false;
        const key = normalizeIconKey(name);
        return key.startsWith('fire_') || key === 'toxic_unveiling_volley';
    }, []);

    const resolveSkillName = useCallback(
        (name: string) => {
            if (!name || !skillIdNames) return name;
            const mapped = skillIdNames[name];
            return mapped || name;
        },
        [skillIdNames]
    );

    const getSkillIconUrl = useCallback(
        (name: string) => {
            if (!name) return null;
            const resolvedName = resolveSkillName(name);
            const stripped = stripParenthetical(resolvedName);
            const directResolved = (
                resolveIcon(resolvedName)
                || resolveIcon(stripped)
            );
            if (directResolved) return directResolved;

            const aliasName = resolveAliasName(resolvedName) || resolveAliasName(stripped);
            const aliasStripped = aliasName ? stripParenthetical(aliasName) : '';
            const preferSkill = isArrowCartAlias(aliasName);
            const nonTraitResolved = (
                (aliasName
                    ? (
                        (preferSkill
                            ? (
                                resolveIcon(aliasName)
                                || resolveIcon(aliasStripped)
                            )
                            : null)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                    )
                    : null)
            );
            if (nonTraitResolved) return nonTraitResolved;

            const traitAliasName = resolveTraitAliasName(resolvedName) || resolveTraitAliasName(stripped);
            const traitAliasStripped = traitAliasName ? stripParenthetical(traitAliasName) : '';
            const traitResolved = (
                (traitAliasName
                    ? (
                        resolveIcon(traitAliasName)
                        || resolveIcon(traitAliasStripped)
                    )
                    : null)
            );
            if (traitResolved) return traitResolved;

            if (/^Skill\\s+\\d+$/i.test(resolvedName)) return getUnknownSkillIconUrl();
            return null;
        },
        [
            gameIconManifest,
            isArrowCartAlias,
            resolveAliasName,
            resolveTraitAliasName,
            resolveSkillName,
            resolveIcon,
            stripParenthetical
        ]
    );

    const getBuffIconUrl = useCallback(
        (name: string) => {
            if (!name) return null;
            const resolvedName = resolveSkillName(name);
            const stripped = stripParenthetical(resolvedName);
            const directResolved = (
                resolveIcon(resolvedName)
                || resolveIcon(stripped)
                || resolveIcon(resolvedName)
                || resolveIcon(stripped)
                || resolveIcon(resolvedName)
                || resolveIcon(stripped)
                || resolveIcon(resolvedName)
                || resolveIcon(stripped)
            );
            if (directResolved) return directResolved;

            const aliasName = resolveAliasName(resolvedName) || resolveAliasName(stripped);
            const aliasStripped = aliasName ? stripParenthetical(aliasName) : '';
            const preferSkill = isArrowCartAlias(aliasName);
            const nonTraitResolved = (
                (aliasName
                    ? (
                        resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || (preferSkill
                            ? (
                                resolveIcon(aliasName)
                                || resolveIcon(aliasStripped)
                            )
                            : null)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                        || resolveIcon(aliasName)
                        || resolveIcon(aliasStripped)
                    )
                    : null)
            );
            if (nonTraitResolved) return nonTraitResolved;

            const traitAliasName = resolveTraitAliasName(resolvedName) || resolveTraitAliasName(stripped);
            const traitAliasStripped = traitAliasName ? stripParenthetical(traitAliasName) : '';
            return (
                (traitAliasName
                    ? (
                        resolveIcon(traitAliasName)
                        || resolveIcon(traitAliasStripped)
                    )
                    : null)
            );
        },
        [
            gameIconManifest,
            isArrowCartAlias,
            resolveAliasName,
            resolveTraitAliasName,
            resolveSkillName,
            resolveIcon,
            stripParenthetical
        ]
    );

    const renderProfessionIcon = (profession?: string, _professionList?: string[], className?: string) => {
        const iconPath = getProfessionIconPath(profession || '');
        if (!iconPath) return null;
        return <img src={iconPath} alt={profession} className={className || "w-5 h-5 object-contain"} />;
    };



    return (
        <div className={containerClass}>
            {expandedSection && (
                <div
                    className={`fixed inset-0 z-40 bg-black/70 backdrop-blur-md modal-backdrop ${expandedSectionClosing ? 'modal-backdrop-exit' : 'modal-backdrop-enter'
                        }`}
                    onClick={closeExpandedSection}
                />
            )}
            <StatsHeader
                embedded={embedded}
                dashboardTitle={dashboardTitle}
                totalLogs={stats.total}
                onBack={onBack}
                devMockAvailable={devMockAvailable}
                devMockUploadState={devMockUploadState}
                onDevMockUpload={handleDevMockUpload}
                uploadingWeb={uploadingWeb}
                onWebUpload={handleWebUpload}
                sharing={sharing}
                onShare={handleShare}
            />

            <WebUploadBanner
                embedded={embedded}
                webUploadMessage={webUploadMessage}
                webUploadUrl={webUploadUrl}
                webUploadBuildStatus={webUploadBuildStatus}
                webCopyStatus={webCopyStatus}
                setWebCopyStatus={setWebCopyStatus}
            />

            <DevMockBanner
                embedded={embedded}
                devMockAvailable={devMockAvailable}
                devMockUploadState={devMockUploadState}
            />

            <div
                id="stats-dashboard-container"
                ref={scrollContainerRef}
                className={scrollContainerClass}
                style={scrollContainerStyle}
            >

                <OverviewSection
                    stats={stats}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <FightBreakdownSection
                    stats={stats}
                    fightBreakdownTab={fightBreakdownTab}
                    setFightBreakdownTab={setFightBreakdownTab}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <TopPlayersSection
                    stats={stats}
                    showTopStats={showTopStats}
                    showMvp={showMvp}
                    topStatsMode={topStatsMode}
                    expandedLeader={expandedLeader}
                    setExpandedLeader={setExpandedLeader}
                    formatTopStatValue={formatTopStatValue}
                    formatWithCommas={formatWithCommas}
                    isMvpStatEnabled={isMvpStatEnabled}
                    renderProfessionIcon={renderProfessionIcon}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <TopSkillsSection
                    stats={stats}
                    getSkillIconUrl={getSkillIconUrl}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <SquadCompositionSection
                    sortedSquadClassData={sortedSquadClassData}
                    sortedEnemyClassData={sortedEnemyClassData}
                    getProfessionIconPath={getProfessionIconPath}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <TimelineSection
                    timelineData={stats.timelineData}
                    timelineFriendlyScope={timelineFriendlyScope}
                    setTimelineFriendlyScope={setTimelineFriendlyScope}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <MapDistributionSection
                    mapData={stats.mapData}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <OffenseSection
                    stats={stats}
                    OFFENSE_METRICS={OFFENSE_METRICS}
                    roundCountStats={roundCountStats}
                    offenseSearch={offenseSearch}
                    setOffenseSearch={setOffenseSearch}
                    activeOffenseStat={activeOffenseStat}
                    setActiveOffenseStat={setActiveOffenseStat}
                    offenseViewMode={offenseViewMode}
                    setOffenseViewMode={setOffenseViewMode}
                    formatWithCommas={formatWithCommas}
                    renderProfessionIcon={renderProfessionIcon}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                />

                <ConditionsSection
                    conditionSummary={conditionSummary}
                    conditionPlayers={conditionPlayers}
                    conditionSearch={conditionSearch}
                    setConditionSearch={setConditionSearch}
                    activeConditionName={activeConditionName}
                    setActiveConditionName={setActiveConditionName}
                    conditionDirection={conditionDirection}
                    setConditionDirection={setConditionDirection}
                    conditionGridClass={conditionGridClass}
                    effectiveConditionSort={effectiveConditionSort as any}
                    setConditionSort={setConditionSort as any}
                    showConditionDamage={showConditionDamage}
                    getBuffIconUrl={getBuffIconUrl}
                    renderProfessionIcon={renderProfessionIcon}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                />

                <DefenseSection
                    stats={stats}
                    DEFENSE_METRICS={DEFENSE_METRICS}
                    defenseSearch={defenseSearch}
                    setDefenseSearch={setDefenseSearch}
                    activeDefenseStat={activeDefenseStat}
                    setActiveDefenseStat={setActiveDefenseStat}
                    defenseViewMode={defenseViewMode}
                    setDefenseViewMode={setDefenseViewMode}
                    roundCountStats={roundCountStats}
                    formatWithCommas={formatWithCommas}
                    renderProfessionIcon={renderProfessionIcon}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                />

                <BoonOutputSection
                    stats={stats}
                    activeBoonCategory={activeBoonCategory}
                    setActiveBoonCategory={(val: string) => setActiveBoonCategory(val as BoonCategory)}
                    activeBoonMetric={activeBoonMetric}
                    setActiveBoonMetric={setActiveBoonMetric}
                    activeBoonTab={activeBoonTab}
                    setActiveBoonTab={setActiveBoonTab}
                    activeBoonTable={activeBoonTable}
                    filteredBoonTables={filteredBoonTables}
                    boonSearch={boonSearch}
                    setBoonSearch={setBoonSearch}
                    formatBoonMetricDisplay={formatBoonMetricDisplay}
                    getBoonMetricValue={getBoonMetricValue}
                    getBuffIconUrl={getBuffIconUrl}
                    renderProfessionIcon={renderProfessionIcon}
                    roundCountStats={roundCountStats}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                />

                <SupportSection
                    stats={stats}
                    SUPPORT_METRICS={SUPPORT_METRICS}
                    supportSearch={supportSearch}
                    setSupportSearch={setSupportSearch}
                    activeSupportStat={activeSupportStat}
                    setActiveSupportStat={setActiveSupportStat}
                    supportViewMode={supportViewMode}
                    setSupportViewMode={setSupportViewMode}
                    cleanseScope={cleanseScope}
                    setCleanseScope={setCleanseScope}
                    roundCountStats={roundCountStats}
                    formatWithCommas={formatWithCommas}
                    renderProfessionIcon={renderProfessionIcon}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                />

                <HealingSection
                    stats={stats}
                    HEALING_METRICS={HEALING_METRICS}
                    activeHealingMetric={activeHealingMetric}
                    setActiveHealingMetric={setActiveHealingMetric}
                    healingCategory={healingCategory}
                    setHealingCategory={setHealingCategory}
                    activeResUtilitySkill={activeResUtilitySkill}
                    setActiveResUtilitySkill={setActiveResUtilitySkill}
                    skillUsageData={skillUsageData}
                    formatWithCommas={formatWithCommas}
                    renderProfessionIcon={renderProfessionIcon}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                />

                <SpecialBuffsSection
                    stats={stats}
                    specialSearch={specialSearch}
                    setSpecialSearch={setSpecialSearch}
                    filteredSpecialTables={filteredSpecialTables}
                    activeSpecialTab={activeSpecialTab}
                    setActiveSpecialTab={setActiveSpecialTab}
                    activeSpecialTable={activeSpecialTable}
                    formatWithCommas={formatWithCommas}
                    getBuffIconUrl={getBuffIconUrl}
                    renderProfessionIcon={renderProfessionIcon}
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                />

                <SkillUsageSection
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    selectedPlayers={selectedPlayers}
                    setSelectedPlayers={setSelectedPlayers}
                    removeSelectedPlayer={removeSelectedPlayer}
                    playerMapByKey={playerMapByKey}
                    groupedSkillUsagePlayers={groupedSkillUsagePlayers}
                    expandedSkillUsageClass={expandedSkillUsageClass}
                    setExpandedSkillUsageClass={setExpandedSkillUsageClass}
                    togglePlayerSelection={togglePlayerSelection}
                    skillUsagePlayerFilter={skillUsagePlayerFilter}
                    setSkillUsagePlayerFilter={setSkillUsagePlayerFilter}
                    skillUsageView={skillUsageView}
                    setSkillUsageView={setSkillUsageView}
                    skillUsageData={skillUsageData}
                    skillUsageSkillFilter={skillUsageSkillFilter}
                    setSkillUsageSkillFilter={setSkillUsageSkillFilter}
                    selectedSkillId={selectedSkillId}
                    setSelectedSkillId={setSelectedSkillId}
                    skillBarData={skillBarData}
                    selectedSkillName={selectedSkillName}
                    skillUsageReady={skillUsageReady}
                    skillUsageAvailable={skillUsageAvailable}
                    isSkillUsagePerSecond={isSkillUsagePerSecond}
                    skillChartData={skillChartData}
                    skillChartMaxY={skillChartMaxY}
                    playerTotalsForSkill={playerTotalsForSkill}
                    hoveredSkillPlayer={hoveredSkillPlayer}
                    setHoveredSkillPlayer={setHoveredSkillPlayer}
                    getLineStrokeColor={getLineStrokeColor}
                    getLineDashForPlayer={getLineDashForPlayer}
                    formatSkillUsageValue={formatSkillUsageValue}
                    getSkillIconUrl={getSkillIconUrl}

                    renderProfessionIcon={renderProfessionIcon}
                />

                <ApmSection
                    expandedSection={expandedSection}
                    expandedSectionClosing={expandedSectionClosing}
                    openExpandedSection={openExpandedSection}
                    closeExpandedSection={closeExpandedSection}
                    isSectionVisible={isSectionVisible}
                    isFirstVisibleSection={isFirstVisibleSection}
                    sectionClass={sectionClass}
                    sidebarListClass={sidebarListClass}
                    apmSpecAvailable={apmSpecAvailable}
                    skillUsageAvailable={skillUsageAvailable}
                    apmSpecTables={apmSpecTables}
                    activeApmSpec={activeApmSpec}
                    setActiveApmSpec={setActiveApmSpec}
                    expandedApmSpec={expandedApmSpec}
                    setExpandedApmSpec={setExpandedApmSpec}
                    activeApmSkillId={activeApmSkillId}
                    setActiveApmSkillId={setActiveApmSkillId}
                    ALL_SKILLS_KEY={ALL_SKILLS_KEY}
                    apmSkillSearch={apmSkillSearch}
                    setApmSkillSearch={setApmSkillSearch}
                    activeApmSpecTable={activeApmSpecTable}
                    activeApmSkill={activeApmSkill}
                    isAllApmSkills={isAllApmSkills}
                    apmView={apmView}
                    setApmView={setApmView}
                    formatApmValue={formatApmValue}
                    formatCastRateValue={formatCastRateValue}
                    formatCastCountValue={formatCastCountValue}
                    getSkillIconUrl={getSkillIconUrl}
                    renderProfessionIcon={renderProfessionIcon}
                />
                {!embedded && <div className="h-24" aria-hidden="true" />}
            </div>

            <StatsMobileNav
                embedded={embedded}
                mobileNavOpen={mobileNavOpen}
                setMobileNavOpen={setMobileNavOpen}
                tocItems={tocItems}
                activeNavId={activeNavId}
                scrollToSection={scrollToSection}
                stepSection={stepSection}
            />
        </div>
    );
}
